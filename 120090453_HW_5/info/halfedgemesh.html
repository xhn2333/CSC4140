<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>csc4140</title><meta http-equiv="Content-Language" content="en"><link rel="stylesheet" href="./halfedgemesh_files/ionicons.min.css">
<link rel="stylesheet" href="./halfedgemesh_files/web-5d805804.css">
<link rel="stylesheet" href="./halfedgemesh_files/katex.min.css">
<link rel="stylesheet" href="./halfedgemesh_files/github-markdown.css">
<link rel="stylesheet" href="./halfedgemesh_files/github.min.css"><style type="text/css">date-input-polyfill{background:#fff;color:#000;text-shadow:none;border:0;padding:0;height:auto;width:auto;line-height:normal;font-family:sans-serif;font-size:14px;position:absolute!important;text-align:center;box-shadow:0 3px 10px 1px rgba(0,0,0,.22);cursor:default;z-index:1;border-radius:5px;-moz-border-radius:5px;-webkit-border-radius:5px;overflow:hidden;display:block}date-input-polyfill[data-open=false]{visibility:hidden;z-index:-100!important;top:0}date-input-polyfill[data-open=true]{visibility:visible}date-input-polyfill select,date-input-polyfill table,date-input-polyfill td,date-input-polyfill th{background:#fff;color:#000;text-shadow:none;border:0;padding:0;height:auto;width:auto;line-height:normal;font-family:sans-serif;font-size:14px;box-shadow:none;font-family:Lato,Helvetica,Arial,sans-serif}date-input-polyfill button,date-input-polyfill select{border:0;border-radius:0;border-bottom:1px solid #dadfe1;height:24px;vertical-align:top;-webkit-appearance:none;-moz-appearance:none}date-input-polyfill .monthSelect-wrapper{width:55%;display:inline-block}date-input-polyfill .yearSelect-wrapper{width:25%;display:inline-block}date-input-polyfill select{width:100%}date-input-polyfill select:first-of-type{border-right:1px solid #dadfe1;border-radius:5px 0 0 0;-moz-border-radius:5px 0 0 0;-webkit-border-radius:5px 0 0 0}date-input-polyfill button{width:20%;background:#dadfe1;border-radius:0 5px 0 0;-moz-border-radius:0 5px 0 0;-webkit-border-radius:0 5px 0 0}date-input-polyfill button:hover{background:#eee}date-input-polyfill table{border-collapse:separate!important;border-radius:0 0 5px 5px;-moz-border-radius:0 0 5px 5px;-webkit-border-radius:0 0 5px 5px;overflow:hidden;max-width:280px;width:280px}date-input-polyfill td,date-input-polyfill th{width:32px;padding:4px;text-align:center;box-sizing:content-box}date-input-polyfill td[data-day]{cursor:pointer}date-input-polyfill td[data-day]:hover{background:#dadfe1}date-input-polyfill [data-selected]{font-weight:700;background:#d8eaf6}</style></head><body><script>$MG={"browserRefresh":false,"activeSemester":{"id":7,"tag":"sp22"},"auth":{"profile":null},"semester":{"id":5,"tag":"su20"}}</script><div id="app-root"><div class="rel" id="app-page"><header class="rel"<div class="full" id="app-page__body"><div class="article"><div class="article-header"><h1>A Primer on the HalfEdgeMesh class</h1></div><div class="article-body"><div class="comp-md markdown-body"><p>Although the half-edge data structure is designed to support general polygon meshes, you can assume that all meshes used in Assignment will be made of <strong>triangles only</strong>. You can also assume that the input mesh is <strong>manifold</strong>, meaning that each vertex is connected to only a single "fan" of triangles. Finally, the input mesh <strong>may have boundaries</strong>, meaning that an edge is connected to exactly two triangles, unless the edge is on the boundary, in which case it is connected to only one triangle.</p>
<p>Note that edge flips and edge splits must preserve the manifold property of the mesh. If you implement them correctly and map all the pointers to the correct mesh elements, the mesh is guaranteed to be manifold. However, if you implement them incorrectly, the mesh will no longer be manifold. The traversal code that renders the mesh onscreen will likely segfault and crash when following pointers of the half-edge data structure, as you may have experienced  when working with linked lists or graph structures in previous classes!</p>
<h2>Getting Started on the <code>HalfedgeMesh</code> Class</h2>
<p>For Assignment 2, we have already provided a C++ implementation of the half-edge data structure. Although the implementation detail may appear daunting at first, especially if you have little prior experience with C++,, the basic interface you will need for this assignment is quite similar to the abstract description of half-edge data structure given in <a href="https://cs184.eecs.berkeley.edu/sp20/lecture/8-22/meshes-and-geometry-processing">lecture</a>.</p>
<p>For example, suppose we are given a face and we want to print all of its vertex positions, we would write a function like the following:</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printVertexPositions</span><span class="hljs-params">(FaceCIter f)</span> </span>{
    HalfEdgeCIter h = f-&gt;halfedge(); <span class="hljs-comment">// get the first half-edge of the face</span>
    <span class="hljs-keyword">do</span> {
        VertexCIter v = h-&gt;vertex(); <span class="hljs-comment">// get the vertex of the current half-edge</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; v-&gt;position &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// print the vertex position</span>
        h = h-&gt;next();               <span class="hljs-comment">// move to the next half-edge around the face</span>
    } <span class="hljs-keyword">while</span> (h != f-&gt;halfedge());    <span class="hljs-comment">// keep going until we are back where we were</span>
}
</code></pre>
<p>For explanations on low-level details, e.g., why we call a <code>FaceCIter</code> instead of just a <code>Face</code>, please refer to this <a href="https://cs184.eecs.berkeley.edu/sp20/article/16/iterators-vs-pointers">short article</a> and documentation in <code>halfedgeMesh.h</code>.</p>
<p>Similarly, to print the positions of all neighbouring vertices of a given vertex, we could write a function like the following. Note a vertex neighbours a given vertex if the two vertices are connected by an edge. You may want to draw a simple mesh, e.g., a fan of triangles around a vertex, and follow along the code to understand why it works.</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printNeighbourPositions</span><span class="hljs-params">(VertexCIter v)</span> </span>{
    HalfEdgeCIter h = v-&gt;halfedge();      <span class="hljs-comment">// get the outgoing half-edge of the vertex</span>
    <span class="hljs-keyword">do</span> {
        HalfEdgeCIter h_twin = h-&gt;twin(); <span class="hljs-comment">// get the opposite half-edge</span>
        VertexCIter v = h_twin-&gt;vertex(); <span class="hljs-comment">// vertex is the 'source' of the half-edge, so</span>
                                          <span class="hljs-comment">// h-&gt;vertex() is v, whereas h_twin-&gt;vertex()</span>
                                          <span class="hljs-comment">// is the neighboring vertex</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; v-&gt;position &lt;&lt; <span class="hljs-built_in">endl</span>;      <span class="hljs-comment">// print the vertex position</span>
        h = h_twin-&gt;next();               <span class="hljs-comment">// move to the next outgoing half-edge of the vertex</span>
    } <span class="hljs-keyword">while</span>(h != v-&gt;halfedge());          <span class="hljs-comment">// keep going until we are back where we were</span>
}
</code></pre>
<p>To iterate over <strong>all</strong> vertices of a half-edge mesh, we can write a simple loop below:</p>
<pre><code class="language-cpp"><span class="hljs-keyword">for</span> (VertexCIter v = mesh.verticesBegin(); v != mesh.verticesEnd(); v++) {
    <span class="hljs-built_in">cout</span> &lt;&lt; v-&gt;position &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// do something interesting here</span>
}
</code></pre>
<p>Internally, the lists of vertices, edges, faces, and half-edges are stored as <strong>linked lists</strong>, which allow us to easily add or delete elements to our mesh.  For instance, to add a new vertex to the mesh, we can write</p>
<pre><code class="language-cpp">VertexIter v = mesh.newVertex();
</code></pre>
<p>Likewise, to delete a vertex from the mesh, we can write</p>
<pre><code class="language-cpp">mesh.deleteVertex(v);
</code></pre>
<p>Note, however, that one should be <strong>very, very careful</strong> when adding or deleting mesh elements. New mesh elements must be properly linked to the mesh. For instance, this new vertex must point to one of its associated half-edges by writing something like below:</p>
<pre><code class="language-cpp">VertexIter v = mesh.newVertex();
v-&gt;halfedge() = h;
</code></pre>
<p>Likewise, if we delete a mesh element, we must be sure that no existing elements is still pointing to it. The half-edge data structure does <strong>not</strong> take care of these relationships for you automatically. In fact, that is exactly the point of Assignment -- to get your some practice directly manipulating the half-edge data structure.  Being able to perform these low-level manipulations will enable you to write useful and interesting mesh processing code far beyond the basic operations in this assignment.</p>
<h2>Mesh Boundary in the <code>HalfedgeMesh</code> Class</h2>
<p>The <strong>boundary</strong> of a mesh, e.g., the ankles and waist of a pair of pants, requires special care in our half-edge implementation. At first glance, the function <code>printNeighborPositions(...)</code> above seems to break if the vertex <code>v</code> is on the boundary, because at some point we will have no <code>twin()</code> half-edge to visit. Fortunately, our implementation has been designed to avoid this kind of problem. In particular, rather than having an actual hole in the mesh, we create a "virtual" boundary face whose edges are all the edges of the boundary loop. This way, we can iterate over boundary elements just like any other mesh element. If we ever need to check whether an element is on the boundary, we have the following methods:</p>
<pre><code class="language-cpp">Vertex::isBoundary(); Edge::isBoundary();
Face::isBoundary(); Halfedge::isBoundary();
</code></pre>
<p>These methods return true if and only if the element is contained in the domain boundary. Additionally, we store an explicit list of boundary faces, which we can iterate over like any other type of mesh elements:</p>
<pre><code class="language-cpp"><span class="hljs-keyword">for</span> (FaceCIter b = mesh.boundariesBegin(); b != mesh.boundariesEnd(); b++) {
    <span class="hljs-comment">// do something interesting in this boundary loop</span>
}
</code></pre>
<p>These virtual boundary faces are not stored in the usual face list, i.e., they will not show up when iterating over faces. The figure below should help further explain how the <code>HalfedgeMesh</code> class handles meshes with boundary:</p>
<p style="text-align:center;">
<img src="./halfedgemesh_files/boundaryConventions.png">
</p>
<p>In the figure, dark blue regions represent interior faces, while light blue regions represent the virtual boundary face. The entire virutal boundary face above is considered as a <strong>single</strong> face, as opposed to being composed of triangles. In other words, the boundary face is a single polygon with 12 edges!</p>
<p>A vertex, edge, or halfedge is considered to be part of the boundary if it is contained entirely in a boundary face. For example, in the figure, vertex <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>v</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup></mrow><annotation encoding="application/x-tex">v'</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>, edge <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>e</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup></mrow><annotation encoding="application/x-tex">e'</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">e</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> and half-edge <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>h</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup></mrow><annotation encoding="application/x-tex">h'</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">h</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> are all part of the boundary; and their respective <code>isBoundary()</code> method will return true. On the other hand, vertex <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">v</span></span></span></span>, edge <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">e</span></span></span></span>, and half-edge <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span></span></span></span> are not part of the boundary; and their respective <code>isBoundary()</code> method will return false.</p>
<p>To truly understand why <code>printNeighborPositions(...)</code> does not break for a boundary vertex, try walking through the function for the vertex <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>v</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup></mrow><annotation encoding="application/x-tex">v'</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> in the figure. What does <code>h-&gt;twin()</code> and <code>h-&gt;twin()-&gt;next()</code> return when <code>h</code> is the half-edge <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span></span></span></span> in the figure?</p>
<p><strong>Important Note:</strong> The edge degree and face degree of a non-boundary vertex is the same. However, the edge degree and face degree of a boundary vertex is <strong>not</strong> the same! For example, the vertex <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>v</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup></mrow><annotation encoding="application/x-tex">v'</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.751892em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> above is contained in three edges but only two interior faces. By convention, <code>Vertex::degree()</code> returns the face degree and <strong>not</strong> the edge degree. For a boundary vertex, we can compute its edge degree by adding 1 to its face degree.</p>
<p>Please refer to documentation in <code>halfedgeMesh.h</code> for further details on the <code>HalfedgeMesh</code> class.</p>
<h2>Possible Pitfalls of Iterating Mesh Elements</h2>
<p>When dealing with a dynamic data structure like a half-edge mesh, one must think <strong>very, very carefully</strong> about the order in which mesh elements are processed. It is quite easy to delete an element at one point in the code and try to access it later, often resulting in a crash! For instance, suppose we write a loop like the following:</p>
<pre><code class="language-cpp"><span class="hljs-comment">// iterate over all edges in the mesh</span>
<span class="hljs-keyword">for</span> (EdgeIter e = mesh.edgesBegin(); e != mesh.edgesEnd(); e++) {
    <span class="hljs-keyword">if</span> (some condition is met) {
        mesh.splitEdge(e);
    }
}
</code></pre>
<p>The code looks pretty simple, but this routine could very easily crash!  Do you see why?  The reason is fairly subtle -- we are iterating over edges in the mesh by incrementing the iterator <code>e</code> via <code>e++</code>. However, since the routine <code>HalfedgeMesh::splitEdge()</code> can create and delete mesh elements, it might deallocate this edge before we get to increment this iterator <code>e</code> to the next edge!  To be safe, we should instead write our loop like the following:</p>
<pre><code class="language-cpp"><span class="hljs-comment">// iterate over all edges in the mesh</span>
EdgeIter e = mesh.edgesBegin();
<span class="hljs-keyword">while</span> (e != mesh.edgesEnd()) {
    
    <span class="hljs-comment">// get the next edge NOW!</span>
    EdgeIter nextEdge = e;
    nextEdge++;
    
    <span class="hljs-comment">// now, even if splitting the edge deletes it ...</span>
    <span class="hljs-keyword">if</span> (some condition is met) {
        mesh.splitEdge(e);
    }
    
    <span class="hljs-comment">// ... we still have a valid reference to the next edge</span>
    e = nextEdge;
}
</code></pre>
<p>Note that this loop is just <strong>one example</strong>. In general, you should think about which elements might be affected by a local mesh operation when writing your loops. You can make your life easier by making sure that your edge flips and edge splits provide certain guarantees. For instance, if your implementation of <code>HalfedgeMesh::flipEdge(...)</code> guarantees that no edges will be created or destroyed, as it should, then you can safely do edge flips inside a loop without having to worry about these kinds of undesired effects.</p>
<h2>Debugging Aid</h2>
<p>We have left four debugging functions near the bottom of <code>halfEdgeMesh.h</code> as members of the <code>HalfEdgeMesh</code> class. They are all called <code>check_for(...)</code>. Given an iterator to one of the four types of mesh object, the function looks through every object in the mesh and finds the ones that point to the given object. Whenever the function finds a match, it prints a message with the address of the pointing object. This could be useful when you want to confirm that an object is pointed to by the right number of other objects, or that those pointing objects have the expected addresses. This will make more sense once you start implementing Section II of Aassignment 2.</p>
<h2>Resources and Notes</h2>
<p>In addition to this write-up, you may find these supplemental notes helpful in guiding your implementation. Note that you do <strong>not</strong> have to handle meshes with boundary, unless you are going for for extra points!</p>
<ul>
<li><a href="http://15462.courses.cs.cmu.edu/fall2015content/misc/HalfedgeEdgeOpImplementationGuide.pdf">Correctly Implementing Edge Flip / Split / Collapse</a></li>
<li><a href="http://15462.courses.cs.cmu.edu/fall2015content/misc/TetrahedronEdgeFlip.pdf">Edge Operations on an Oriented Triangle Mesh</a></li>
<li><a href="http://15462.courses.cs.cmu.edu/fall2015content/misc/HalfedgeBoundary.pdf">Conventions for Meshes with Boundary</a></li>
</ul>
<p>Here is another tutorial on the half-edge data structure:</p>
<ul>
<li><a href="http://www.flipcode.com/archives/The_Half-Edge_Data_Structure.shtml">The Half-Edge Data Structure</a></li>
</ul>
<p>The following paper features a different implementation of half-edge data structure from the one used in Assignment 2, but it discusses some of the software design challenges associated with building a half-edge data structure that is worth reading.</p>
<ul>
<li><a href="https://www.graphics.rwth-aachen.de/media/papers/openmesh1.pdf">OpenMesh</a></li>
</ul>
</div></div></div></div><footer id="app-footer"></footer></div></div><script src="./halfedgemesh_files/cs184-web-a09c6a18.js.下载"></script>
<script>$_mod_cal184.ready();</script><date-input-polyfill data-open="false"><span class="yearSelect-wrapper"><select class="yearSelect"><option value="1890">1890</option><option value="1891">1891</option><option value="1892">1892</option><option value="1893">1893</option><option value="1894">1894</option><option value="1895">1895</option><option value="1896">1896</option><option value="1897">1897</option><option value="1898">1898</option><option value="1899">1899</option><option value="1900">1900</option><option value="1901">1901</option><option value="1902">1902</option><option value="1903">1903</option><option value="1904">1904</option><option value="1905">1905</option><option value="1906">1906</option><option value="1907">1907</option><option value="1908">1908</option><option value="1909">1909</option><option value="1910">1910</option><option value="1911">1911</option><option value="1912">1912</option><option value="1913">1913</option><option value="1914">1914</option><option value="1915">1915</option><option value="1916">1916</option><option value="1917">1917</option><option value="1918">1918</option><option value="1919">1919</option><option value="1920">1920</option><option value="1921">1921</option><option value="1922">1922</option><option value="1923">1923</option><option value="1924">1924</option><option value="1925">1925</option><option value="1926">1926</option><option value="1927">1927</option><option value="1928">1928</option><option value="1929">1929</option><option value="1930">1930</option><option value="1931">1931</option><option value="1932">1932</option><option value="1933">1933</option><option value="1934">1934</option><option value="1935">1935</option><option value="1936">1936</option><option value="1937">1937</option><option value="1938">1938</option><option value="1939">1939</option><option value="1940">1940</option><option value="1941">1941</option><option value="1942">1942</option><option value="1943">1943</option><option value="1944">1944</option><option value="1945">1945</option><option value="1946">1946</option><option value="1947">1947</option><option value="1948">1948</option><option value="1949">1949</option><option value="1950">1950</option><option value="1951">1951</option><option value="1952">1952</option><option value="1953">1953</option><option value="1954">1954</option><option value="1955">1955</option><option value="1956">1956</option><option value="1957">1957</option><option value="1958">1958</option><option value="1959">1959</option><option value="1960">1960</option><option value="1961">1961</option><option value="1962">1962</option><option value="1963">1963</option><option value="1964">1964</option><option value="1965">1965</option><option value="1966">1966</option><option value="1967">1967</option><option value="1968">1968</option><option value="1969">1969</option><option value="1970">1970</option><option value="1971">1971</option><option value="1972">1972</option><option value="1973">1973</option><option value="1974">1974</option><option value="1975">1975</option><option value="1976">1976</option><option value="1977">1977</option><option value="1978">1978</option><option value="1979">1979</option><option value="1980">1980</option><option value="1981">1981</option><option value="1982">1982</option><option value="1983">1983</option><option value="1984">1984</option><option value="1985">1985</option><option value="1986">1986</option><option value="1987">1987</option><option value="1988">1988</option><option value="1989">1989</option><option value="1990">1990</option><option value="1991">1991</option><option value="1992">1992</option><option value="1993">1993</option><option value="1994">1994</option><option value="1995">1995</option><option value="1996">1996</option><option value="1997">1997</option><option value="1998">1998</option><option value="1999">1999</option><option value="2000">2000</option><option value="2001">2001</option><option value="2002">2002</option><option value="2003">2003</option><option value="2004">2004</option><option value="2005">2005</option><option value="2006">2006</option><option value="2007">2007</option><option value="2008">2008</option><option value="2009">2009</option><option value="2010">2010</option><option value="2011">2011</option><option value="2012">2012</option><option value="2013">2013</option><option value="2014">2014</option><option value="2015">2015</option><option value="2016">2016</option><option value="2017">2017</option><option value="2018">2018</option><option value="2019">2019</option><option value="2020">2020</option><option value="2021">2021</option><option value="2022">2022</option><option value="2023">2023</option><option value="2024">2024</option><option value="2025">2025</option><option value="2026">2026</option><option value="2027">2027</option><option value="2028">2028</option><option value="2029">2029</option><option value="2030">2030</option><option value="2031">2031</option><option value="2032">2032</option><option value="2033">2033</option><option value="2034">2034</option><option value="2035">2035</option><option value="2036">2036</option><option value="2037">2037</option><option value="2038">2038</option><option value="2039">2039</option><option value="2040">2040</option><option value="2041">2041</option><option value="2042">2042</option></select></span><span class="monthSelect-wrapper"><select class="monthSelect"></select></span><button>Today</button><table><thead></thead><tbody></tbody></table></date-input-polyfill><script>(function(){var w=window;w.$components=(w.$components||[]).concat({"r":"M","w":[["s0-0-0-3-10",0,{"to":"/comments","l":"comments"},{"f":1,"s":{"active":false},"w":{"target":"/su20/comments"}}],["s0-0-0-3-9",0,{"to":"/resources","l":"resources"},{"f":1,"s":{"active":false},"w":{"target":"/su20/resources"}}],["s0-0-0-3-8",0,{"to":"/readings","l":"readings"},{"f":1,"s":{"active":false},"w":{"target":"/su20/readings"}}],["s0-0-0-3-7",0,{"to":"/staff","l":"staff"},{"f":1,"s":{"active":false},"w":{"target":"/su20/staff"}}],["s0-0-0-3-6",0,{"to":"/policies","l":"policies"},{"f":1,"s":{"active":false},"w":{"target":"/su20/policies"}}],["s0-0-0-3-5",0,{"to":"/","l":"cs184/284a"},{"f":1,"s":{"active":false},"w":{"target":"/su20"}}]],"t":["/cal-184-website$3.2.0/client/components/comp-nav-link/index.marko"]})||w.$components})()</script></body></html>